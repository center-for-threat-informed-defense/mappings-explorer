{% extends "base.html.j2" %} {% block content %}
<div id="search">
  <Search url_prefix="{{url_prefix}}"></Search>
</div>

<script src="{{url_prefix}}static/lunr.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<script>
  const Search = {
    template: `
      <div>
        <section id="header-container" class="header-container">
          <div class="container" data-aos="fade-up">
            <h1 style="text-transform: uppercase" class="text-left">
              <span class="highlight">Search</span> for Mappings
            </h1>
          </div>
        </section>
        <section>
          <div class="container" data-aos="fade-up">
            <h2>PAGES FOR "[[ search.toUpperCase() ]]"</h2>
            <div
              class="result-container"
              v-for="result in displayedResultKeys"
              :key="result"
            >
              <div v-if="results[result].pageData.type !== 'attack_object'">
                <a class="result-title" :href="url_prefix + results[result].ref"> [[ results[result].pageData.name ]] </a>
                <div class="result-subtext">
                  <span>Page for [[ results[result].pageData.mapping_framework ]] [[ results[result].pageData.type ]] [[ results[result].pageData.name]]</span>
                  <span class="float-right">
                    ATT&CK Version: <b>[[ getStringFromUrl(results[result].ref, "attack-") ]]</b>
                    ATT&CK Domain: <b>[[ getStringFromUrl(results[result].ref, "domain-") ]]</b>
                  </span>
                </div>
              </div>
              <div v-else>
                <a class="result-title" :href="url_prefix + results[result].ref"> [[ results[result].pageData.id ]] [[ results[result].pageData.name ]]</a>
                <div class="result-subtext">
                  <span>
                    Page for ATT&CK [[ results[result].pageData.id.includes('.') ? 'subtechnique' : 'technique' ]]
                    [[ results[result].pageData.id ]] [[ results[result].pageData.name]]
                  </span>
                  <span class="float-right">
                    ATT&CK Version: <b>[[ getStringFromUrl(results[result].ref, "attack-") ]]</b>
                    ATT&CK Domain: <b>[[ getStringFromUrl(results[result].ref, "domain-") ]]</b>
                  </span>
                </div>
              </div>
            </div>
            <nav>
              <span>
                Showing [[ parseInt(displayedResultKeys[0]) + 1 ]]  to [[ parseInt(displayedResultKeys[displayedResultKeys.length - 1]) + 1 ]] of [[ resultsLength ]] pages
                <select v-model="itemsPerPage">
                  <option
                    v-for="item in itemPerPageOptions.filter(option => option <= resultsLength)"
                    :value="item"
                  >
                    [[ item ]]
                  </option>
                </select>
                items per page
              </span>
              <ul class="pagination float-right">
                <li class="pagination-item previous" v-if="pageNum > 1" @click="pageNum --">
                  Previous
                </li>
                <li
                  :class="{
                    'pagination-item': true,
                    'previous': index === 1 && pageNum === 1,
                    'next': index === amountOfPages && pageNum === index,
                    'pagination-item--active': pageNum === index
                  }"
                  v-for="index in amountOfPages"
                  @click="pageNum = index"
                >
                 [[ index ]]
                </li>
                <li class="pagination-item next" v-if="pageNum < amountOfPages" @click="pageNum++">
                  Next
                </li>
              </ul>
            </nav>
          </div>
        </section>
      </div>
  `,
    delimiters: ["[[", "]]"],
    props: {
      url_prefix: String,
    },
    data() {
      return {
        webPages: undefined,
        index: undefined,
        results: {},
        search: "",
        pageNum: 1,
        itemsPerPage: 10,
        itemPerPageOptions: [10, 25, 50, 100]
      };
    },
    computed:{
      displayedResultKeys(){
        // get results that are on the current page
        return Object.keys(this.results).filter(r => (r >= (this.pageNum - 1) * this.itemsPerPage) && (r <= (this.pageNum - 1) * this.itemsPerPage + this.itemsPerPage - 1));
      },
      resultsLength(){
        return Object.keys(this.results).length;
      },
      amountOfPages(){
        return Math.ceil(this.resultsLength / this.itemsPerPage);
      }
    },
    methods: {
      getStringFromUrl(url, string) {
        let returnStringAndOn = url.substring(url.indexOf(string) + string.length);
        let returnString = returnStringAndOn.substring(0, returnStringAndOn.indexOf("/"));
        if (returnString === "enterprise" || returnString === "mobile"){
          return returnString.charAt(0).toUpperCase() + returnString.slice(1);
        }
        else if(returnString === 'ics'){
          return "ICS";
        }
        return returnString
      },
      /**
       * Initialize the search index.
       */
      async initializeSearch(indexUrl) {
        const indexResponse = await fetch(indexUrl);
        const indexJson = await indexResponse.json();
        this.webPages = indexJson["pages"];
        this.index = lunr.Index.load(indexJson["index"]);
        console.log("Search index is initialized.");
      },

      /**
       * Run a query on the search index and return the results.
       */
      searchIndex(query) {
        if (!this.index) {
          console.error("Search index is not initialized.");
          return;
        }

        const allResults = this.index.search(query);
        for (const result of allResults) {
          result.pageData = this.webPages[result.ref];
        }

        return {
          query,
          results: allResults,
          totalCount: allResults.length,
        };
      },
      async searchMain() {
        const url = new URL(window.location.href);
        if (url.searchParams.get("search")) {
          let search = url.searchParams.get("search");
          this.search = search;
          document.getElementById("nav-search-input").value = search;
          this.initializeSearch(
            `${this.url_prefix}static/lunr-index.json`
          ).then(() => {
            let results = this.searchIndex(search);
            this.results = results.results;
          });
        }
      },
    },
    mounted() {
      this.searchMain();
    },
  };

  const app = new Vue({
    el: "#search",
    components: {
      Search: Search,
    },
  });
</script>
<style>
  .result-container {
    background-color: white;
    padding: 20px;
    box-shadow: 2px 2px 4px #bdbdbd;
    margin-bottom: 10px;
    border-radius: 5px;
  }
  .result-subtext {
    margin-left: 1rem;
  }
  .result-title {
    font-size: 18px;
  }
  .pagination-item {
    padding: 10px;
    background-color: white;
    cursor: pointer;
    border-right: 1px solid #dee2e6;
    border-top: 1px solid #dee2e6;
    border-bottom: 1px solid #dee2e6;
    min-width: 40px;
    text-align: center;
    color: #6241c5;
  }
  .pagination-item--active {
    background-color: #6241c5;
    color: white;
  }
  .pagination-item:hover {
    background-color: #dee2e6;
    color: #495057;
  }
  .pagination-item--active:hover {
    background-color: #6241c5;
    color: white;
  }
  .next {
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
  }
  .previous {
    border-top-left-radius: 5px;
    border-bottom-left-radius: 5px;
    border-left: 1px solid #dee2e6;
  }
  .float-right {
    float: right;
  }
</style>
{% endblock content %}
